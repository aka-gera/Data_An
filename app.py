# -*- coding: utf-8 -*-
"""Copy of app_v3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sv7iLw5j1Vtxyd92vZYE324KkFjg7VuM
"""

# !pip install dash
# # !pip install dash==1.19.0
# !pip install jupyter_dash
# !pip install --upgrade plotly
# !pip install dash --upgrade
# !pip install dash_bootstrap_components

"""<!--  -->"""

# Import required libraries
import pandas as pd
import dash
from dash import dcc
from dash import html
from dash import Dash, dcc, html, dash_table, Input, Output, State, callback
from dash.dependencies import Input, Output, State
from jupyter_dash import JupyterDash
import plotly.graph_objects as go
import plotly.express as px
from dash import no_update
import dash_bootstrap_components as dbc


#  import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
# Allows us to test parameters of classification algorithms and find the best one
from sklearn.model_selection import GridSearchCV
# Logistic Regression classification algorithm
from sklearn.linear_model import LogisticRegression
# Support Vector Machine classification algorithm
from sklearn.linear_model import LinearRegression

from sklearn import preprocessing
from sklearn.preprocessing import LabelEncoder
import tensorflow as tf

from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
import plotly.figure_factory as ff

import plotly.graph_objects as go
from sklearn.tree import DecisionTreeClassifier

from sklearn.metrics import accuracy_score
 
import datetime
import io  

tcouleur = 'plotly_dark'
bcouleur = 'navy'
fcouleur = 'white'
fsize = 20


def plot_history_dash(dfm,feat):
    fig_cm = px.histogram(data_frame= dfm,x=feat,opacity= 0.7)

    fig_cm.update_layout(
       barmode='overlay',
        # paper_bgcolor=bcouleur,  # Set the background color here
        font=dict(color=fcouleur,size=fsize),  # Set the font color to here
        title_x=0.5,
        title_y=0.9,
        template=tcouleur
    )
    return fig_cm

def plot_history_all_dash(dfm ):
    fig  = px.histogram(data_frame= dfm,opacity= .7).update_xaxes(categoryorder='total descending')
    fig .update_layout(
       barmode='overlay',
        # paper_bgcolor=bcouleur,  # Set the background color here
        font=dict(color=fcouleur,size=fsize),  # Set the font color to here
        title_x=0.5,
        title_y=0.9,
        template=tcouleur
    )
    fig.update_xaxes(
            title_font = {"size": 14},
            title_standoff = 25)
    return fig

def plot_confusion_matrix_dash(y,y_predict,cmLabel,lab):
    cm = confusion_matrix(y, y_predict)
    if lab == 1:
        fig = ff.create_annotated_heatmap(cm,
                                          x=cmLabel[:cm.shape[1]],
                                          y=cmLabel[:cm.shape[1]],
                                          colorscale='Viridis',showscale=True)
        fig.update_xaxes(
                title_text='Predicted labels',
                title_font = {"size": 18},
                title_standoff = 25,
                side='bottom')
        fig.update_yaxes(
                title_text = 'True labels',
                title_font = {"size": 18},
                title_standoff = 25)
    else:
        annotation_text = [['' for _ in range(cm.shape[1])] for _ in range(cm.shape[0])]
        fig = ff.create_annotated_heatmap(cm,
                                          x=cmLabel[:cm.shape[1]],
                                          y=cmLabel[:cm.shape[1]],
                                          colorscale='Viridis',
                                          annotation_text=annotation_text,
                                          showscale=True)
        fig.update_xaxes(
                title_text='Prediction',
                title_font = {"size": 18},
                title_standoff = 25,
                side='bottom')
        # fig.update_xaxes(  showticklabels=False )
        fig.update_yaxes(
                title_text = 'True Solution',
                title_font = {"size": 18},
                title_standoff = 25,
                showticklabels=False  # Hide the x-axis
                )
    fig.update_layout(
        title='Confusion Matrix',
        font=dict(color=fcouleur,size=fsize),  # Set the font color to here
        template=tcouleur
    )
    fig.update_layout(
        # paper_bgcolor=bcouleur,  # Set the background color here
        font=dict(color=fcouleur,size=fsize),  # Set the font color to here
        title_x=0.5,
        title_y=0.9,
        template=tcouleur
    )
    return fig

def plot_classification_report_dash(y, y_predict,cmLabel,lab):

    report_str = classification_report(y, y_predict,  zero_division=0)
    report_lines = report_str.split('\n')

    # Remove empty lines
    report_lines = [line for line in report_lines if line.strip()]
    data = [line.split() for line in report_lines[1:]]
    colss = ['feature', 'precision',   'recall',  'f1-score',   'support', 'n1one']

    # Convert to a DataFrame
    report_df = pd.DataFrame(data, columns = colss )
    report_df = report_df[report_df.columns[:-1]]
    cm = report_df.iloc[:-3,1:].apply(pd.to_numeric).values
    colss1 = [  'precision',   'recall',  'f1-score',   'support']
    if lab == 1:
        fig_cm = ff.create_annotated_heatmap(cm,
                                             x = colss1,
                                             y = cmLabel[:cm.shape[0]],
                                             colorscale='Viridis' )
        fig_cm.update_yaxes(
                 title_text = 'y',
                title_font = {"size": 18},
                title_standoff = 25,
                showticklabels=False  # Hide the x-axis
                )
    else:
        cmm =  cm[:,:-1]
        annotation_text = [['' for _ in range(cmm.shape[1])] for _ in range(cmm.shape[0])]
        fig_cm = ff.create_annotated_heatmap(cmm,
                                             x = colss1[:-1],
                                             colorscale='Viridis',
                                             showscale=True,
                                             annotation_text=annotation_text )
        fig_cm.update_yaxes(
                 title_text = 'y',
                title_font = {"size": 18},
                # title_standoff = 25,
                showticklabels=False  # Hide the x-axis
                )
    fig_cm.update_layout(
          title='Classification Report',
          # paper_bgcolor=bcouleur,  # Set the background color here
          font=dict(color=fcouleur,size=fsize),  # Set the font color to here
          title_x=0.5,
          title_y=0.9,
          template=tcouleur
      )
    return fig_cm

from sklearn.tree import DecisionTreeClassifier
def ML_DecisionTreeClassifier(X_train, X_test, y_train, y_test,X_pred) :
    clf = DecisionTreeClassifier()
    clf.fit(X_train, y_train)
    return clf.predict(X_test),clf.predict(X_pred),clf.score(X_test, y_test)

from sklearn.linear_model import LogisticRegression
def ML_LogisticRegression(X_train, X_test, y_train, y_test,X_pred) :
    clf = LogisticRegression(solver='lbfgs', max_iter=1000)
    clf.fit(X_train, y_train)
    return clf.predict(X_test),clf.predict(X_pred),clf.score(X_test, y_test)

from sklearn.svm import SVC
def ML_SVC(X_train, X_test, y_train, y_test,X_pred) :
    clf = SVC()
    clf.fit(X_train, y_train)
    return clf.predict(X_test),clf.predict(X_pred),clf.score(X_test, y_test)

from sklearn.neighbors import KNeighborsClassifier
def ML_KNeighborsClassifier(X_train, X_test, y_train, y_test,X_pred) :
    clf = KNeighborsClassifier()
    clf.fit(X_train, y_train)
    return clf.predict(X_test),clf.predict(X_pred),clf.score(X_test, y_test)

from sklearn.naive_bayes import GaussianNB
def ML_KNeighborsClassifier(X_train, X_test, y_train, y_test,X_pred) :
    clf = GaussianNB()
    clf.fit(X_train, y_train)
    return clf.predict(X_test),clf.predict(X_pred),clf.score(X_test, y_test)

from sklearn.linear_model import SGDClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
def ML_SGDClassifier(X_train, X_test, y_train, y_test,X_pred) :
    clf = make_pipeline(StandardScaler(), SGDClassifier(max_iter=2500, tol=1e-3, penalty = 'elasticnet'))
    clf.fit(X_train, y_train)
    return clf.predict(X_test),clf.predict(X_pred),clf.score(X_test, y_test)

def ChooseML(ml, X_train, X_test, y_train, y_test,X_pred, cmLabel,shw):

    if ml == 'LG' :
        y_pred_LG,y_pred,scre = ML_LogisticRegression(X_train, X_test, y_train, y_test,X_pred)
        fig2 = plot_confusion_matrix_dash(y_test,y_pred_LG,cmLabel,shw)
        fig3 = plot_classification_report_dash(y_test,y_pred_LG,cmLabel,shw)
    elif ml == 'DT':
        y_pred_DT,y_pred,scre = ML_DecisionTreeClassifier(X_train, X_test, y_train, y_test,X_pred)
        fig2 = plot_confusion_matrix_dash(y_test,y_pred_DT,cmLabel,shw)
        fig3 = plot_classification_report_dash(y_test,y_pred_DT,cmLabel,shw)
    elif ml == 'KNN':
        y_pred_KNN,y_pred,scre = ML_KNeighborsClassifier(X_train, X_test, y_train, y_test,X_pred)
        fig2 = plot_confusion_matrix_dash(y_test,y_pred_KNN,cmLabel,shw)
        fig3 = plot_classification_report_dash(y_test,y_pred_KNN,cmLabel,shw)
    elif ml == 'SVC':
        y_pred_SVC,y_pred,scre = ML_SVC(X_train, X_test, y_train, y_test,X_pred)
        fig2 = plot_confusion_matrix_dash(y_test,y_pred_SVC,cmLabel,shw)
        fig3 = plot_classification_report_dash(y_test,y_pred_SVC,cmLabel,shw)
    elif ml == 'NB':
        y_pred_NB,y_pred,scre = ML_KNeighborsClassifier(X_train, X_test, y_train, y_test,X_pred)
        fig2 = plot_confusion_matrix_dash(y_test,y_pred_NB,cmLabel,shw)
        fig3 = plot_classification_report_dash(y_test,y_pred_NB,cmLabel,shw)
    elif ml == 'SGD':
        y_pred_SGD,y_pred,scre = ML_SGDClassifier(X_train, X_test, y_train, y_test,X_pred)
        fig2 = plot_confusion_matrix_dash(y_test,y_pred_SGD,cmLabel,shw)
        fig3 = plot_classification_report_dash(y_test,y_pred_SGD,cmLabel,shw)



    return fig2,fig3,y_pred,scre
 
def Cleaning(df):
    dff = df
    cmLabel = [ '`'+str(elm) for elm in df[df.columns[-1]].dropna().unique()]


    nrows,ncols = df.shape
    nom = ['Feature'+str(i) for i in range(ncols)]
    df.columns = nom

    typOfVar = []
    for j in range(ncols):
        for i,elm in df[df.columns[j]].dropna().items():
            if isinstance(elm,str):
                typOfVar.append(j)
                break

    mapping = {}
    for j in typOfVar:
        mapping[df.columns[j]] = {}
        uniq = df[df.columns[j]].dropna().unique()
        for i in range(len(uniq)):
            key = uniq[i]
            mapping[df.columns[j]][key] = i

    for j in typOfVar:
        df[df.columns[j]] = df[df.columns[j]].map(mapping[df.columns[j]])


    for j in range(ncols):
        mode1 = df[df.columns[j]].mode()
        df[df.columns[j]] = df[df.columns[j]].fillna(mode1[0])

    return  df,dff,cmLabel,typOfVar,mapping,ncols

def CleaningPred(df,typOfVar,mapping):

    nrows,ncols = df.shape
    nom = ['Feature'+str(i) for i in range(ncols)]
    df.columns = nom

    # typOfVar = []
    # for j in range(ncols):
    #     for i,elm in df[df.columns[j]].dropna().items():
    #         if isinstance(elm,str):
    #             typOfVar.append(j)
    #             break

    for j in typOfVar:
        df[df.columns[j]] = df[df.columns[j]].map(mapping[df.columns[j]])


    for j in range(ncols):
        mode1 = df[df.columns[j]].mode()
        df[df.columns[j]] = df[df.columns[j]].fillna(mode1[0])

    return  df

def Algorithm(df,dfpred):

    df,dff,cmLabel,typOfVar,mapping,ncols = Cleaning(df )

    # dfpred,dff,cmLabel,typOfVar,mapping,ncols = Cleaning(dfpred )
    dfpred = CleaningPred(dfpred,typOfVar,mapping)
    # print(df.head(5))
    # print(dfpred.head(5))

    cols = list(df[df.columns[:-1]].columns)
    X = df[dff.columns[:-1]].values
    Y = df[dff.columns[-1]].values

    X_pred = dfpred[dff.columns[:-1]].values

    X_train, X_test, y_train, y_test = train_test_split( X, Y, test_size=0.3, random_state=4)

    return  dff,X_train, X_test, y_train, y_test,X_pred, cmLabel,typOfVar,mapping

# zip_url = 'https://archive.ics.uci.edu/static/public/42/glass+identification.zip'
# zip_url = 'https://archive.ics.uci.edu/static/public/1/abalone.zip'
# zip_url = 'https://archive.ics.uci.edu/static/public/53/iris.zip'
# # zip_url = 'https://archive.ics.uci.edu/static/public/19/car+evaluation.zip'
# # zip_url = 'https://archive.ics.uci.edu/static/public/15/breast+cancer+wisconsin+original.zip'
# zip_url = 'https://archive.ics.uci.edu/static/public/30/contraceptive+method+choice.zip'
# # zip_url = 'https://archive.ics.uci.edu/static/public/2/adult.zip'
# # url =  'https://archive.ics.uci.edu/static/public/19/car+evaluation.zip'
# ext = 'data'
# shw = 0
# df = My_Zip(zip_url,'data')
# # _,dropdown_options_style,dropdown_options, _, _, _, _, cmLabel = Algorithm(df)
# dff,X_train, X_test, y_train, y_test,X_pred, cmLabel,typOfVar,mapping = Algorithm(df,df)

# print(X_train)
# print(X_pred.shape)

# fig2,fig3,y_pred,scre = ChooseML('DT', X_train, X_test, y_train, y_test,X_pred, cmLabel,shw)

# y_pred

# fig2.show()

def parse_contents(contents, filename, date):
    content_type, content_string = contents.split(',')

    decoded = base64.b64decode(content_string)
    try:
        if 'data' or 'csv' in filename:
            # Assume that the user uploaded a CSV file
            df = pd.read_csv(
                io.StringIO(decoded.decode('utf-8')))
        elif 'xls' in filename:
            # Assume that the user uploaded an excel file
            df = pd.read_excel(io.BytesIO(decoded))
    except Exception as e:
        print(e)
        return html.Div([
            'There was an error processing this file.'
        ]), None  # Return None for the DataFrame if there was an error

    # Display the first 5 rows
    first_5_rows = df.head(5)

    return html.Div([
        html.H5(filename),
        html.H6(datetime.datetime.fromtimestamp(date)),

        dash_table.DataTable(
            first_5_rows.to_dict('records'),
            [{'name': i, 'id': i} for i in first_5_rows.columns]
        ),

        html.Hr(),  # horizontal line

        # For debugging, display the raw contents provided by the web browser
        html.Div('Raw Content'),
        html.Pre(contents[0:200] + '...', style={
            'whiteSpace': 'pre-wrap',
            'wordBreak': 'break-all'
        })
    ]), df  # Return the DataFrame along with other components

def dfDownload(data):
    df = pd.DataFrame(data)

    # Create a CSV file from the DataFrame
    csv_content = df.to_csv(index=False)

    # Create a base64-encoded version of the CSV content
    # encoded_content = base64.b64encode(csv_content.encode()).decode("utf-8")

    # Define the file name and type for download
    file_name = "prediction.csv"
    file_type = "text/csv"

    file_dict = {
        "content": csv_content,
        "filename": file_name,
        "type": file_type,  # Corrected property name
    }

    return file_dict

shw = 0

dropdown_options_style = {'color': 'white', 'background-color' : 'gray'}

dropdown_options = [
    {'label': 'All Features', 'value': 'ALL', 'style': dropdown_options_style}
]

for col in range(100):
    dropdown_options.append({'label': 'Feature'+str(col), 'value': 'Feature'+str(col), 'style':  dropdown_options_style})

box_style={
            'width':'80%',
            'padding':'3px',
            'font-size': '20px',
            'text-align-last' : 'center' ,
            'margin': 'auto',  # Center-align the dropdown horizontally
            'background-color' : 'black',
            'color': 'black'
            }
# Create a dash application Cyborg

app =  dash.Dash(__name__, external_stylesheets=[dbc.themes.DARKLY])
JupyterDash.infer_jupyter_proxy_config()

server = app.server
app.config.suppress_callback_exceptions = True

app.layout = html.Div(
    style={
        'color' : 'black',
        'backgroundColor': 'black',  # Set the background color of the app here
        'height': '100vh'  # Set the height of the app to fill the viewport
    },
    children=[
    html.Br(),
    html.Br(),
    html.Br(),
    html.H1('Dataset Analysis',
            style={'textAlign': 'center',
                   'color': 'white',
                   'background-color' : 'black',
                   'font-size': 40
                   }
            ),
    html.Br(),

    html.Br(),
    html.Div([
        html.H1("Upload the training data",
            style={'textAlign': 'center',
                        'color': 'white',
                        'background-color' : 'black',
                        'margin': 'auto',  # Center-align the dropdown horizontally
                        'font-size': 20
                        }
             ),
    dcc.Upload(
         id='upload-data',
        children=html.Div([
            'Drag and Drop or ',
            html.A('Select Files')
        ]),
        style={
            'display': 'flex',
            'justify-content': 'center',
            'width': '50%',
            'height': '50px',
            'margin': 'auto',  # Center-align the dropdown horizontally
            'color': 'black',
            'background-color' : 'grey',
            } ,
        multiple=True
    ),
    # html.Div(id='output-data-upload'),
    # dcc.Graph(id='column-plot')  # Graph component to display the plot
]),

    html.Br(),
    html.Div([
        html.H1("Upload the data to predict",
            style={'textAlign': 'center',
                        'color': 'white',
                        'background-color' : 'black',
                        'margin': 'auto',  # Center-align the dropdown horizontally
                        'font-size': 20
                        }
             ),
    dcc.Upload(
      id='upload-data2',
        children=html.Div([
            'Drag and Drop or ',
            html.A('Select Files')
        ]),
        style={
            'display': 'flex',
            'justify-content': 'center',
            'width': '50%',
            'height': '50px',
            'margin': 'auto',  # Center-align the dropdown horizontally
            'color': 'black',
            'background-color' : 'grey',
            } ,
        multiple=True
    ),
    # html.Div(id='output-data-upload'),
    # dcc.Graph(id='column-plot')  # Graph component to display the plot
]),

    html.Br(),
    html.Br(),



    html.Div('Analysis of the dataset and evaluation of various classification machine algorithms',
            style={'textAlign': 'center',
                'color': 'white',
                'background-color' : 'black',
                'font-size': 35
                }
            ),
    html.Br(),
          # Create an outer division
     html.Div([
            html.Div([
                html.Div([
                  dcc.Dropdown(
                      id='site-dropdown1',
                      options=dropdown_options,
                      value='ALL',
                      placeholder='Select a feature',
                      style=box_style,
                      searchable=True
                  ) ,
                  html.Div(id='output-graph1') ,
                ]),
        ]),
        html.Div([
            dcc.Dropdown(
                id='site-dropdown2',
                options=[
                        {'label':  'Logistic Regression',          'value': 'LG',   'style':  dropdown_options_style},
                        {'label': 'Decision Tree Classifier',      'value': 'DT',   'style':  dropdown_options_style},
                        {'label': 'K-Nearest Neighbors',           'value': 'KNN',  'style':  dropdown_options_style},
                        {'label': 'Support Vector Classification', 'value': 'SVC',  'style':  dropdown_options_style},
                        {'label': 'Gaussian Naive Bayes',          'value': 'NB',   'style':  dropdown_options_style},
                        {'label': 'Stochastic Gradient Descent',   'value': 'SGD',  'style':  dropdown_options_style}
                        ],
                value='LG',
                placeholder='Select a Machine Learning Classifier',
                style=box_style,
                searchable=True,
            ) ,
        html.Div([
            html.Div(id='output-graph2', style={'width': '50%', 'display': 'inline-block'}),
            html.Div(id='output-graph3', style={'width': '50%', 'display': 'inline-block'}),
        ]),
        ]),
     ]),
        html.Br(),
    html.Br(),
    html.Div(id='output-text'),
    html.Br(),
    html.Br(),
 html.Div([
    html.H1("Download the predicted result based on the selected machine learning algorithm: ",
            style={'textAlign': 'center',
                        'color': 'white',
                        'background-color' : 'black',
                        'font-size': 20
                        }
             ),
    dcc.Download(id="download-button"),
    html.Button("Download Prediction",
                id="btn-download",
                style={
                    'display': 'flex',
                    'justify-content': 'center',
                    'background-color': 'grey'
                    }
                ),
        ],
    style={
        'display': 'flex',
        'justify-content': 'center',
        }
          ),
    html.Br(),
    html.Br(),
])








@app.callback([
        # Output('output-data-upload', 'children'),
        # Output('column-plot', 'figure'),
        Output('output-graph1', 'children'),
        Output('output-graph2', 'children'),
        Output('output-graph3', 'children'),
        Output('output-text', 'children'),
         Output("download-button", "data"),
    ],
    [
        Input('upload-data', 'contents'),
        Input('upload-data', 'filename'),
        Input('upload-data', 'last_modified'),


        Input('upload-data2', 'contents'),
        Input('upload-data2', 'filename'),
        Input('upload-data2', 'last_modified'),
        Input('site-dropdown1', 'value'),
        Input('site-dropdown2', 'value'),
        Input("btn-download", "n_clicks"),
        # Input('input-text', 'contents'),
        ],
        prevent_initial_call=True
              )



def update_output(list_of_contents, list_of_names, list_of_dates,list_of_contents2, list_of_names2, list_of_dates2,feature,ml,n_clicks):
    if [list_of_contents,list_of_contents2] is not None:
        # Parse the contents and get the DataFrame
        children_and_df = [
            parse_contents(c, n, d) for c, n, d in
            zip(list_of_contents, list_of_names, list_of_dates)]

        # children = [item[0] for item in children_and_df]  # Extract the HTML components
        df = [item[1] for item in children_and_df if item[1] is not None][0]  # Extract the DataFrame


        children_and_df2 = [
            parse_contents(c, n, d) for c, n, d in
            zip(list_of_contents2, list_of_names2, list_of_dates2)]

        dfpred = [item[1] for item in children_and_df2 if item[1] is not None][0]  # Extract the DataFrame

        dff,X_train, X_test, y_train, y_test,X_pred, cmLabel,typOfVar,mapping = Algorithm(df,dfpred)
        filtered_df = dff[dff.columns[0:-1]]


        if feature == 'ALL':
            figure1 =  dcc.Graph( figure = plot_history_all_dash(filtered_df ) )
        else:
            figure1 =  dcc.Graph( figure = plot_history_dash(filtered_df,feature) )

        fig2,fig3,y_pred,scre = ChooseML(ml, X_train, X_test, y_train, y_test,X_pred, cmLabel,shw)

        fig2 = dcc.Graph( figure = fig2)
        fig3 = dcc.Graph( figure = fig3)

        txt_output = html.Div( ['The overall accuracy of the selected algorithm is ',f'{scre*100 :.2f}','%'],
            style={'textAlign': 'center', 'color': 'white', 'background-color' : 'black',   'font-size': 20}
                )

        if n_clicks is None:
            butpred = dash.no_update  # Don't trigger download if the button hasn't been clicked
        else:
            butpred =dfDownload(y_pred)

        return  [  figure1,fig2,fig3,txt_output,butpred]



# Run the app
if __name__ == '__main__':
    app.run_server(  debug=False)
